
enum Function {}

enum Token {
  Keyword {value: str},
  Operator {value: str},
  String {value: str},
  Character {value: char},
}

struct State {
  token: Token,
  nextToken: Token,
  code: str,
}

enum Expression {
  Bool_literal {value: bool},
  Character_literal {value: char},
  In_place_assignment {operator: str, target: Expression, is_prefix: bool},
  Qualified_name {value: vec<str>},
  String_literal {value: str},
  Unary_operation {operator: str, operand: Expression},
  Identity_test {is_negative: bool, operand: Expression, variant: vec<str>},
}

fn read_primary_expression(
  ref state: State,
  __read_expression: Function,
): Expression {

  if (state.token is String) {
    let value = state.token.value;
    read_token(&state);
    return String_literal {value};
  }
  if (state.token is Character) {
    let value = state.token.value;
    read_token(&state);
    return Character_literal {value};
  }
  if (has_keyword(state, "true")) {
    read_token(&state);
    return Bool_literal {value: true};
  }
  if (has_keyword(state, "false")) {
    read_token(&state);
    return Bool_literal {value: false};
  }

  if (has_operator(state, "++")) {
    let operator = state.token.value;
    read_token(&state);
    let target = read_primary_expression(&state, __read_expression);
    return In_place_assignment {operator, target, is_prefix: true};
  }

  if (has_operator(state, "!")) {
    let operator = state.token.value;
    read_token(&state);
    let operand = read_primary_expression(&state, __read_expression);
    return Unary_operation {operator, operand};
  }

  if (has_keyword(state, "set") || has_keyword(state, "vec")) {
    let dataType = state.token.value;
    read_token(&state);
    invariant(has_operator(state, "["));
    read_token(&state);
    let values = vec [];
    while (!has_operator(state, "]")) {
      let expression = read_expression(&state);
      __push(values, expression);
      if (has_operator(state, ",")) {
        read_token(&state);
      } else {
        invariant(has_operator(state, "]"));
      }
    }
    read_token(&state);
    return Collection_literal {dataType, values};
  }

  let qualified_name = None {};
  if (has_identifier(state)) {
    qualified_name = read_qualified_name(&state);
  }

  if (has_operator(state, '{')) {
    read_token(&state);
    let fields = vec [];
    while (has_identifier(state)) {
      let name = state.token.value;
      read_token(&state);
      let is_shorthand = !has_operator(state, ':');
      let value = None {};
      if (!is_shorthand) {
        read_token(&state);
        value = read_expression(&state);
      }
      if (has_operator(state, ',')) {
        read_token(&state);
      } else {
        invariant(has_operator(state, '}'));
      }
      __push(fields, {name, value, is_shorthand});
    }
    invariant(has_operator(state, '}'));
    read_token(&state);
    return Object_literal {typeName: qualified_name, fields};
  }
  invariant(qualified_name isnt None);

  if (has_operator(state, '[')) {
    read_token(&state);
    let key = read_expression(&state);
    invariant(has_operator(state, ']'));
    read_token(&state);
    return Collection_access {collectionName: qualified_name, key};
  }

  if (has_operator(state, '(')) {
    read_token(&state);
    let arguments = vec [];
    while (!has_operator(state, ')')) {
      __push(arguments, read_call_argument(&state, __read_expression));
      if (has_operator(state, ',')) {
        read_token(&state);
      } else {
        invariant(has_operator(state, ')'));
      }
    }
    read_token(&state);
    return Function_call {functionName: qualified_name, arguments};
  }
  return Qualified_name {value: qualified_name};
}

fn read_qualified_name(ref state: State): vec<str> {
  invariant(has_identifier(state));
  let qualifiedName = vec [state.token.value];
  read_token(&state);
  while (has_operator(state, '.')) {
    read_token(&state);
    invariant(has_identifier(state));
    __push(qualifiedName, state.token.value);
    read_token(&state);
  }
  return qualifiedName;
}

fn read_call_argument(
  ref state: State,
  __read_expression: Function,
): Expression {

  if (has_operator(state, '&')) {
    read_token(&state);
    invariant(has_identifier(&state));
    let name = state.token.value;
    read_token(&state);
    return Reference {name: name};
  }
  return Expression {value: read_expression(&state)};
}

fn has_keyword(state: State, value: str): bool {
  return state.token is Keyword && state.token.value == value;
}

fn has_operator(state: State, value: str): bool {
  return state.token is Operator && state.token.value == value;
}

fn has_identifier(ref state: State): bool {
  return state.token is Identifier;
}

fn read_token(ref state: State) {
  read_whitespace(&state);
  state.token = state.nextToken;
  state.nextToken = read_next_token(&state);
}

fn read_next_token(ref state: State): Token {
  if (state.i == state.code.length) {
    return End_of_file {};
  }
  if (is_alpha(state.code[state.i])) {
    return read_identifier(&state);
  }
  let OPERATOR_PREFIXES = set ['|', '(', ')', '{', '}', '=', ';', ':', ',', '.',
    '&', '<', '>', '/', '*', '+', '[', ']', '!', '-'];
  if (__has(OPERATOR_PREFIXES, state.code[state.i])) {
    return read_operator(&state);
  }
  if (state.code[state.i] == '"') {
    return read_string_literal(&state);
  }
  if (state.code[state.i] == "'") {
    return read_character_literal(&state);
  }
  __die("unexpected character '" + state.code[state.i] + "'");
}

fn read_whitespace(ref state: State) {
  let whitespace = set [' ', '\n'];
  while (state.i < state.code.length && __has(whitespace, state.code[state.i])) {
    ++state.i;
  }
}

fn read_identifier(ref state: State): Token {
  let keywords = set ["let", "fn", "ref", "while", "true",
    "false", "set", "dict", "vec", "if", "else", "is", "isnt", "return",
    "enum", "struct"];

  let value = state.code[state.i];
  ++state.i;
  while (state.i < state.code.length && is_alphanumeric(state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  if (__has(keywords, value)) {
    return Keyword {value};
  }
  return Identifier {value};
}

fn is_alphanumeric(c: char): bool {
  return is_alpha(c) || c >= '0' && c <= '9';
}

fn is_alpha(c: char): bool {
  return c == '_' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
}

fn read_operator(ref state: State): Operator {
  let operators = set ["&&", "++", "==", "!=", "||", ">=", "<="];
  let value = state.code[state.i];
  ++state.i;
  if (__has(operators, value + state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  return Operator {value};
}

fn read_string_literal(ref state: State): String {
  ++state.i;
  let value = "";
  while (state.i < state.code.length && state.code[state.i] != '"') {
    if (state.code[state.i] == '\\')  {
      ++state.i;
      value = value + get_escaped_char(state.code[state.i]);
    } else {
      value = value + state.code[state.i];
    }
    ++state.i;
  }
  invariant(state.i < state.code.length);
  let token = String {value: value};
  ++state.i;
  return token;
}

fn read_character_literal(ref state: State): Character {
  ++state.i;
  invariant(state.i < state.code.length);
  let value = "";
  if (state.code[state.i] == '\\') {
    ++state.i;
    invariant(state.i < state.code.length);
    value = get_escaped_char(state.code[state.i]);
  } else {
    value = state.code[state.i];
  }
  ++state.i;
  invariant(state.i < state.code.length && state.code[state.i] == "'");
  ++state.i;
  return Character {value: value};
}

fn get_escaped_char(code: char): char {
  if (code == 'n') {
    return '\n';
  }
  invariant (code == '\\' || code == '\'' || code == '"');
  return code;
}

fn invariant(cond: bool) {
  if (!cond) __die("invariant failed");
}
