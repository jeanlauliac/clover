
enum Token {
  Keyword {value: str},
  Operator {value: str},
  String {value: str},
  Character {value: char},
  Identifier {value: str},
  Number {value: str},
  End_of_file,
}

struct State {
  token: Token,
  nextToken: Token,
  code: str,
  i: u32,
}

enum Expression {
  Bool_literal {value: bool},
  Character_literal {value: char},
  In_place_assignment {operator: str, target: Expression, is_prefix: bool},
  Qualified_name {value: vec<str>},
  String_literal {value: str},
  Number_literal {value: str},
  Unary_operation {operator: str, operand: Expression},
  Identity_test {is_negative: bool, operand: Expression, variant: vec<str>},
}

fn __read_expression(ref state: State): Expression {}

fn read_primary_expression(
  ref state: State,
): Expression {

  if (state.token is String) {
    let value = state.token.value;
    read_token(&state);
    return String_literal {value};
  }
  if (state.token is Number) {
    let value = state.token.value;
    read_token(&state);
    return Number_literal {value};
  }
  if (state.token is Character) {
    let value = state.token.value;
    read_token(&state);
    return Character_literal {value};
  }
  if (has_keyword(state, "true")) {
    read_token(&state);
    return Bool_literal {value: true};
  }
  if (has_keyword(state, "false")) {
    read_token(&state);
    return Bool_literal {value: false};
  }

  if (has_operator(state, "(")) {
    read_token(&state);
    let expression = __read_expression(&state);
    invariant(has_operator(state, ")"));
    read_token(&state);
    return expression;
  }

  if (state.token is Operator && has_operator(state, "++")) {
    let operator = state.token.value;
    read_token(&state);
    let target = read_primary_expression(&state);
    return In_place_assignment {operator, operation: "++",
        target, is_prefix: true};
  }

  if (state.token is Operator && (has_operator(state, "!") || has_operator(state, "-"))) {
    let operator = state.token.value;
    read_token(&state);
    let operand = read_primary_expression(&state);
    return Unary_operation {operator, operand};
  }

  if (state.token is Keyword && (has_keyword(state, "set") || has_keyword(state, "vec"))) {
    let dataType = state.token.value;
    read_token(&state);
    invariant(has_operator(state, "["));
    read_token(&state);
    let values = vec [];
    while (!has_operator(state, "]")) {
      let expression = __read_expression(&state);
      __push(values, expression);
      if (has_operator(state, ",")) {
        read_token(&state);
      } else {
        invariant(has_operator(state, "]"));
      }
    }
    read_token(&state);
    return Collection_literal {dataType, values};
  }

  let qualified_name = vec [];
  if (state.token is Identifier) {
    qualified_name = read_qualified_name(&state);
  }

  if (has_operator(state, "{")) {
    read_token(&state);
    let fields = vec [];
    while (state.token is Identifier) {
      let name = state.token.value;
      read_token(&state);
      let is_shorthand = !has_operator(state, ":");
      let value = None {};
      if (!is_shorthand) {
        read_token(&state);
        value = __read_expression(&state);
      }
      if (has_operator(state, ",")) {
        read_token(&state);
      } else {
        invariant(has_operator(state, "}"));
      }
      __push(fields, {name, value, is_shorthand});
    }
    invariant(has_operator(state, "}"));
    read_token(&state);
    return Object_literal {typeName: qualified_name, fields};
  }
  invariant(__size_vec(qualified_name) > 0);

  if (has_operator(state, "[")) {
    read_token(&state);
    let key = __read_expression(&state);
    invariant(has_operator(state, "]"));
    read_token(&state);
    return Collection_access {collectionName: qualified_name, key};
  }

  if (has_operator(state, "(")) {
    read_token(&state);
    let arguments = vec [];
    while (!has_operator(state, ")")) {
      __push(arguments, read_call_argument(&state));
      if (has_operator(state, ",")) {
        read_token(&state);
      } else {
        invariant(has_operator(state, ")"));
      }
    }
    read_token(&state);
    return Function_call {functionName: qualified_name, arguments};
  }
  return Qualified_name {value: qualified_name};
}

fn read_qualified_name(ref state: State): vec<str> {
  invariant(state.token is Identifier);
  let qualifiedName = vec [state.token.value];
  read_token(&state);
  while (has_operator(state, ".")) {
    read_token(&state);
    invariant(state.token is Identifier);
    __push(qualifiedName, state.token.value);
    read_token(&state);
  }
  return qualifiedName;
}

struct Call_argument {
  is_by_reference: bool,
  value: Expression,
}

fn read_call_argument(ref state: State): Call_argument {
  let is_by_reference = false;
  if (has_operator(state, "&")) {
    read_token(&state);
    is_by_reference = true;
  }
  return Call_argument {value: __read_expression(&state), is_by_reference};
}

fn has_keyword(state: State, value: str): bool {
  return state.token is Keyword && state.token.value == value;
}

fn has_operator(state: State, value: str): bool {
  return state.token is Operator && state.token.value == value;
}

fn read_token(ref state: State) {
  read_whitespace(&state);
  state.token = state.nextToken;
  state.nextToken = read_next_token(&state);
}

fn read_next_token(ref state: State): Token {
  if (state.i == __size(state.code)) {
    return End_of_file {};
  }
  if (is_alpha(state.code[state.i])) {
    return read_identifier(&state);
  }
  if (is_numeric(state.code[state.i])) {
    return read_number(&state);
  }
  let OPERATOR_PREFIXES = set ['|', '(', ')', '{', '}', '=', ';', ':', ',', '.',
    '&', '<', '>', '/', '*', '+', '[', ']', '!', '-'];
  if (__has(OPERATOR_PREFIXES, state.code[state.i])) {
    return read_operator(&state);
  }
  if (state.code[state.i] == '"') {
    return read_string_literal(&state);
  }
  if (state.code[state.i] == '\'') {
    return read_character_literal(&state);
  }
  __die("unexpected character '" + state.code[state.i] + "'");
}

fn read_whitespace(ref state: State) {
  let whitespace = set [' ', '\n'];
  while (state.i < __size(state.code) && __has(whitespace, state.code[state.i])) {
    ++state.i;
  }
}

fn read_identifier(ref state: State): Token {
  let keywords = set ["let", "fn", "ref", "while", "true",
    "false", "set", "dict", "vec", "if", "else", "is", "isnt", "return",
    "enum", "struct"];

  let value = "" + state.code[state.i];
  ++state.i;
  while (state.i < __size(state.code) && is_alphanumeric(state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  if (__has_str(keywords, value)) {
    return Keyword {value};
  }
  return Identifier {value};
}

fn read_number(ref state: State): Token {
  let value = "" + state.code[state.i];
  ++state.i;
  while (state.i < __size(state.code) && is_numeric(state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  return Number {value};
}

fn is_alphanumeric(c: char): bool {
  return is_alpha(c) || is_numeric(c);
}

fn is_alpha(c: char): bool {
  return c == '_' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
}

fn is_numeric(c: char): bool {
  return c >= '0' && c <= '9';
}

fn read_operator(ref state: State): Operator {
  let operators = set ["&&", "++", "==", "!=", "||", ">=", "<="];
  let value = "" + state.code[state.i];
  ++state.i;
  if (__has_str(operators, value + state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  return Operator {value};
}

fn read_string_literal(ref state: State): String {
  ++state.i;
  let value = "";
  while (state.i < __size(state.code) && state.code[state.i] != '"') {
    if (state.code[state.i] == '\\')  {
      ++state.i;
      value = value + get_escaped_char(state.code[state.i]);
    } else {
      value = value + state.code[state.i];
    }
    ++state.i;
  }
  invariant(state.i < __size(state.code));
  let token = String {value: value};
  ++state.i;
  return token;
}

fn read_character_literal(ref state: State): Character {
  ++state.i;
  invariant(state.i < __size(state.code));
  let value = "";
  if (state.code[state.i] == '\\') {
    ++state.i;
    invariant(state.i < __size(state.code));
    value = get_escaped_char(state.code[state.i]);
  } else {
    value = "" + state.code[state.i];
  }
  ++state.i;
  invariant(state.i < __size(state.code) && state.code[state.i] == '\'');
  ++state.i;
  return Character {value: value};
}

fn get_escaped_char(code: char): char {
  if (code == 'n') {
    return '\n';
  }
  invariant (code == '\\' || code == '\'' || code == '"');
  return code;
}

fn invariant(cond: bool) {
  if (!cond) __die("invariant failed");
}
