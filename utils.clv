fn main() {
  let code = __read_file("./clover_comp.clv");
  let state = {
    code: code,
    phase: "module",
    token: None {},
    next_token: None {},
  };

  read_token(&state);
  read_token(&state);

  let module = read_module(&state);

  __write("#!/usr/bin/env node\n\n");
}

fn read_module(ref state: State) {
  let module = {functions: vec[]};
  while (state.token isnt End_of_file) {
    read_module_declaration(&state, &module);
  }
  return module;
}

fn has_keyword(ref state: State, ref value: string) {
  return state.token is Keyword && state.token.value == value;
}

fn has_operator(ref state: State, ref value: string) {
  return state.token is Operator && state.token.value == value;
}

fn has_identifier(ref state: State) {
  return state.token is Identifier;
}

fn read_token(ref state: State) {
  read_whitespace(&state);
  state.token = state.nextToken;
  state.nextToken = read_next_token(&state);
}

fn read_next_token(ref state: State) {
  if (state.i == state.code.length) {
    return End_of_file {};
  }
  if (is_alpha(state.code[state.i])) {
    return read_identifier(&state);
  }
  let OPERATOR_PREFIXES = set ['|', '(', ')', '{', '}', '=', ';', ':', ',', '.',
    '&', '<', '>', '/', '*', '+', '[', ']', '!', '-'];
  if (__has(OPERATOR_PREFIXES, state.code[state.i])) {
    return read_operator(&state);
  }
  if (state.code[state.i] == '"') {
    return read_string_literal(&state);
  }
  if (state.code[state.i] == "'") {
    return read_character_literal(&state);
  }
  __die("unexpected character '" + state.code[state.i] + "'");
}

fn read_whitespace(ref state: State) {
  let whitespace = set [' ', '\n'];
  while (state.i < state.code.length && __has(whitespace, state.code[state.i])) {
    ++state.i;
  }
}

fn read_identifier(ref state: State) {
  let KEYWORKS = set ["let", "fn", "ref", "while", "true",
  "false", "set", "dict", "vec", "if", "else", "is", "isnt", "return"];

  let value = state.code[state.i];
  ++state.i;
  while (state.i < state.code.length && is_alphanumeric(state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  if (__has(KEYWORKS, value)) {
    return Keyword {value: value};
  }
  return Identifier {value: value};
}

fn is_alphanumeric(c: char) {
  return is_alpha(c) || c >= '0' && c <= '9';
}

fn is_alpha(c: char) {
  return c == '_' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
}

fn read_operator(ref state: State) {
  let OPERATORS = set ["&&", "++", "==", "!=", "||", ">=", "<="];
  let value = state.code[state.i];
  ++state.i;
  if (__has(OPERATORS, value + state.code[state.i])) {
    value = value + state.code[state.i];
    ++state.i;
  }
  return Operator {value: value};
}

fn read_string_literal(ref state: State) {
  ++state.i;
  let start = state.i;
  while (state.i < state.code.length && state.code[state.i] != '"') {
    ++state.i;
  }
  invariant(state.i < state.code.length);
  let token = String_literal {value: __substring(state.code, start, state.i)};
  ++state.i;
  return token;
}

fn read_character_literal(ref state: State) {
  ++state.i;
  invariant(state.i < state.code.length);
  let value = "";
  if (state.code[state.i] == '\\') {
    ++state.i;
    invariant(state.i < state.code.length);
    value = get_escaped_char(state.code[state.i]);
  } else {
    value = state.code[state.i];
  }
  ++state.i;
  invariant(state.i < state.code.length && state.code[state.i] == "'");
  ++state.i;
  return Character_literal {value: value};
}

fn get_escaped_char(code: char) {
  if (code == 'n') {
    return '\n';
  }
  if (code == '\\') {
    return '\\';
  }
  invariant(false);
}

fn invariant(cond: bool) {
  if (!cond) __die("invariant failed");
}
